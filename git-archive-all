#! /usr/bin/env python

__version__ = "1.4.2"

import sys
from os import path, chdir
from subprocess import Popen, PIPE


class GitArchiver(object):
    """
    GitArchiver

    Scan a git repository and export all tracked files, and submodules.
    Checks for .gitattributes files in each directory and uses 'export-ignore'
    pattern entries for ignore files in the archive.

    Automatically detects output format extension: zip, tar, bz2, or gz
    """

    def __init__(self, prefix='', verbose=False, exclude=True, force_sub=False, extra=[]):
        self.prefix = prefix
        self.verbose = verbose
        self.exclude = exclude
        self.extra = extra
        self.force_sub = force_sub

    def create(self, output_file_path):
        """
        create(str output_file_path) -> None

        Creates the archive, written to the given output_file_path
        Filetype may be one of:  gz, zip, bz2, tar, tgz
        """
        #
        # determine the format
        #
        _, _, format = output_file_path.rpartition(".")
        format = format.lower()

        if format == 'zip':
            from zipfile import ZipFile, ZIP_DEFLATED
            output_archive = ZipFile(path.abspath(output_file_path), 'w')
            add = lambda name, arcname: output_archive.write(name, self.prefix + arcname, ZIP_DEFLATED)

        elif format in ['tar', 'bz2', 'gz', 'tgz']:
            import tarfile

            if format == 'tar':
                t_mode = 'w'
            elif format == 'tgz':
                t_mode = 'w:gz'
            else:
                t_mode = ('w:%s' % format)

            output_archive = tarfile.open(path.abspath(output_file_path), t_mode)
            add = lambda name, arcname: output_archive.add(name, self.prefix + arcname)
        else:
            raise RuntimeError("Unknown format: '%s'" % format)

        #
        # compress
        #

        # extra files first (we may change folder later)
        for name in self.extra:
            if self.verbose:
                to_path = '=> %s%s' % (self.prefix, name) if self.prefix else ""
                print 'Compressing %s %s ...' % (name, to_path)
            add(name, name)

        for name, arcname in self.list_files(path.abspath('')):
            if self.verbose:
                to_path = '=> %s%s' % (self.prefix, arcname) if self.prefix else ""
                print 'Compressing %s %s ...' % (arcname, to_path)
            add(name, arcname)

        output_archive.close()

    def get_exclude_patterns(self, get_repo_path):
        patterns = []
        attributes_path = path.join(get_repo_path, '.gitattributes')
        if path.isfile(attributes_path):
            attributes_file = open(attributes_path, 'r')
            for line in attributes_file:
                if not line:
                    break
                tokens = line.strip().split()
                if 'export-ignore' in tokens[1:]:
                    patterns.append(tokens[0])
            attributes_file.close()
        return patterns

    def list_files(self, git_main_repo_path, git_submodule_repo_path=''):
        """
        An iterator method that yields a tuple(file_path, full_file_path)
        for each file that should be included in the archive.
        Skips those that match the exclusion patterns found in
        any discovered .gitattributes files along the way.

        Recurses into submodules as well.

        @type git_main_repo_path:   string
        @param git_main_repo_path:  Path to the main git repository.

        @type git_submodule_repo_path:  string
        @param git_submodule_repo_path: Path to the submodule relative to git_main_repo_path.

        @rtype:     iterator
        @return:    Iterator to traverse tuples representing files in the git repo.
                    The tuple consist of file_path (relative to the cwd) and full_file_path (relative to git_main_repo_path)
        """
        if self.exclude:
            exclude_patterns = self.get_exclude_patterns(path.join(git_main_repo_path, git_submodule_repo_path))
        else:
            exclude_patterns = []

        for file_path in self.run_shell('git ls-files --cached --full-name --no-empty-directory'):
            file_path = file_path.decode('string_escape').strip('"')  # file path relative to current repo
            file_name = path.basename(file_path)

            # Only list symlinks and files that don't start with git.
            if file_name.startswith('.git') or (not path.islink(file_path) and path.isdir(file_path)):
                continue

            full_file_path = path.join(git_submodule_repo_path, file_path)  # file path relative to the main repo

            # Check the exclude patterns first.
            ignore = False
            for pattern in exclude_patterns:
                from fnmatch import fnmatch

                if fnmatch(full_file_path, pattern) or fnmatch(file_name, pattern):
                    if self.verbose:
                        print 'Exclude pattern matched (%s): %s' % (pattern, full_file_path)
                    ignore = True
                    break
            if ignore:
                continue

            # Yield both file_path and full_file_path to preserve structure of the repo.
            yield file_path, full_file_path

        if self.force_sub:
            self.run_shell("git submodule init")
            self.run_shell("git submodule update")

        # List files of every submodule.
        for submodule_path in self.run_shell("git submodule --quiet foreach 'pwd'"):
            chdir(submodule_path)
            # In order to get output path we need to exclude repository path from submodule_path.
            submodule_path = path.relpath(submodule_path, git_main_repo_path)
            for file_tuple in self.list_files(git_main_repo_path, submodule_path):
                yield file_tuple

    @staticmethod
    def run_shell(cmd):
        return Popen(cmd, shell=True, stdout=PIPE).stdout.read().splitlines()


if __name__ == "__main__":
    from optparse import OptionParser

    parser = OptionParser(usage="usage: %prog [-v] [--prefix PREFIX] [--no-exclude] OUTPUT_FILE", version="%prog {version}".format(version=__version__))

    parser.add_option('--prefix', type='string', dest='prefix',
                      default='', help="Prepend PREFIX to each filename in the archive.\
                      OUTPUT_FILE name is used by default to avoid tarbomb.")

    parser.add_option('-v', '--verbose', action='store_true', dest='verbose', help='Enable verbose mode.')

    parser.add_option('--no-exclude', action='store_false', dest='exclude',
                      default=True, help="Don't read .gitattributes files for patterns containing export-ignore attrib.")

    parser.add_option('--force-submodules', action='store_true', dest='force_sub',
                      help="Force a git submodule init && git submodule update at each level before iterating submodules.")

    parser.add_option('--extra', action='append', dest='extra', default=[],
                      help="Any additional files to include in the archive.")

    options, args = parser.parse_args()

    if len(args) != 1:
        parser.error('You must specify exactly one output file')

    output_file_path = args[0]

    if path.isdir(output_file_path):
        parser.error('You cannot use directory as output')

    # avoid tarbomb
    if options.prefix:
        options.prefix = path.join(options.prefix, '')
    else:
        import re
        output_name = path.basename(output_file_path)
        output_name = re.sub('(\.zip|\.tar|\.tgz|\.gz|\.bz2|\.tar\.gz|\.tar\.bz2)$', '', output_name) or 'archive'
        options.prefix = path.join(output_name, '')

    archiver = GitArchiver(options.prefix,
                           options.verbose,
                           options.exclude,
                           options.force_sub,
                           options.extra)

    try:
        archiver.create(output_file_path)
    except Exception, e:
        parser.exit(2, "%s\n" % e)

    sys.exit(0)
